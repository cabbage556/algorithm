# 리스트 자료형
#       여러 개의 데이터를 연속적으로 담아 처리하기 위해 사용하는 자료형
#       내부적으로 연결 리스트 자료구조를 채택하고 있음
#       append(), remove() 등의 메서드를 지원함

# 리스트 만들기
#       대괄호 안에 원소를 넣어 초기화, 쉼표로 원소를 구분함
#       대괄호 안에 인덱스를 넣어 원소에 접근함
#       비어 있는 리스트 선언 방법: list(), []
a = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(a)
print(a[4])  # 인덱스 4번 원소 접근

# 빈 리스트 선언
a = list()
print(a)  # []

a = []
print(a)  # []

# 크기가 N이고, 모든 값이 0인 1차원 리스트를 초기화하는 방법
n = 10
a = [0] * n
print(a)


# 리스트의 인덱싱과 슬라이싱
# 인덱싱: 인덱스값을 입력해 리스트의 특정 원소에 접근하는 것
#       파이썬 리스트의 인덱스값은 양의 정수, 음의 정수를 모두 사용 가능
#       음의 정수를 사용하면 원소를 거꾸로 탐색함
#           -1: 가장 마지막 원소(뒤에서 첫 번째 원소)
a = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(a[-1])  # 9: 뒤에서 첫 번째 원소
print(a[-3])  # 7: 뒤에서 세 번째 원소

# 슬라이싱: 리스트의 연속적인 위치에서 원소를 가져오기 위해 사용함
#       슬라이싱 방법: [시작 인덱스:(끝 인덱스-1)]
#       리스트를 슬라이싱하면 리스트가 반환됨
b = a[1:4]  # 인덱스1부터 인덱스3까지 슬라이싱(인덱스4는 제외)
print(b)  # [2, 3, 4]


# 리스트 컴프리헨션
#       리스트 초기화 방법 중 하나
#       대괄호 안에 조건문, 반복문을 넣어 리스트 초기화 가능
#       리스트를 간단하게 초기화할 수 있다는 장점이 있음
# 0부터 19까지의 수 중에서 홀수만 포함하는 리스트 초기화
a = [i for i in range(20) if i % 2 == 1]
print(a)  # [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]

# 0부터 9까지 수의 제곱 값을 포함하는 리스트 초기화
a = [i * i for i in range(10)]
print(a)  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# 리스트 컴프리헨션이 효과적인 경우
#       특정 크기의 2차원 리스트 초기화
# n x m 크기의 2차원 리스트 초기화
n = 3
m = 4
a = [[0] * m for _ in range(n)]
print(a)  # [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]

# 특정 크기의 2차원 리스트 초기화 시 리스트 컴프리헨션을 반드시 사용해야 함
n = 3
m = 4
a = [[0] * m] * n
a[1][1] = 5
print(a)
# 출력 결과
#       [[0, 5, 0, 0], [0, 5, 0, 0], [0, 5, 0, 0]]
#       3개의 리스트 모두 인덱스1에 해당하는 원소들이 5로 변경됨
#       내부적으로 3개의 리스트가 모두 동일한 객체를 참조하기 때문
#       따라서 특정 크기의 2차원 리스트 초기화 시 반드시 리스트 컴프리헨션을 사용해야 함


# 리스트 관련 메서드
a = [1, 4, 3]

# append(값) 메서드
#       리스트에 원소 하나 삽입, O(1)
a.append(2)
print(a)  # [1, 4, 3, 2]

# sort() 메서드
#       오름차순으로 정렬함, O(NlogN)
a.sort()
print(a)  # [1, 2, 3, 4]

# sort(reverse=True) 메서드
#       내림차순으로 정렬함, O(NlogN)
a.sort(reverse=True)
print(a)  # [4, 3, 2, 1]

# reverse() 메서드
#       리스트의 원소의 순서 뒤집기, O(N)
a.reverse()
print(a)  # [1, 2, 3, 4]

# insert(삽입할 인덱스, 삽입할 값)
#       특정 인덱스에 원소를 삽입함, O(N)
a.insert(2, 3)
print(a)  # [1, 2, 3, 3, 4]

# count(특정 값)
#       리스트에서 특정 값을 갖는 원소의 개수를 계산, O(N)
print(a.count(3))  # 2

# remove(특정 값)
#       리스트에서 특정 값을 갖는 원소를 제거함
#       만약 여러 개라면 첫 번째만 제거함, O(N)
a.remove(3)  # 첫 번째, 3인 원소 제거
print(a)

# 코테에서 리스트 메서드 사용 시 리스트가 내부적으로 연결 리스트인 점을 고려해야 함
#       insert() 메서드를 많이 사용하면 '시간 초과' 발생 가능
#           인덱스에 원소 삽입 후 나머지 원소들의 위치를 조절해야 하기 때문
#           시간 복잡도: O(N)
#       remove() 메서드를 많이 사용하면 '시간 초과' 발생 가능
#           원소 제거 후 나머지 원소들의 위치를 조절해야 하기 때문
#           시간 복잡도: O(N)

# 특정 값을 갖는 모든 원소를 제거하는 방법
a = [1, 2, 3, 4, 5, 5, 5]
rmv_set = {3, 5}  # 포함하지 않을 값들
res = [i for i in a if i not in rmv_set]
print(res)  # [1, 2, 4]
